   1               		.file	"dynamixel.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	calculatechecksum:
  13               	.LFB17:
  14               		.file 1 "libs/dynamixel/dynamixel.c"
   1:libs/dynamixel/dynamixel.c **** #include <avr/io.h>
   2:libs/dynamixel/dynamixel.c **** #include <util/delay.h>
   3:libs/dynamixel/dynamixel.c **** #include <avr/interrupt.h>
   4:libs/dynamixel/dynamixel.c **** #include <string.h>
   5:libs/dynamixel/dynamixel.c **** 
   6:libs/dynamixel/dynamixel.c **** #include "dynamixel.h"
   7:libs/dynamixel/dynamixel.c **** 
   8:libs/dynamixel/dynamixel.c **** // General
   9:libs/dynamixel/dynamixel.c **** static uint8_t calculatechecksum(volatile uint8_t* packet);
  10:libs/dynamixel/dynamixel.c **** static uint8_t readpacket(
  11:libs/dynamixel/dynamixel.c **** 	volatile uint8_t* rxpacket, 
  12:libs/dynamixel/dynamixel.c **** 	uint8_t packetlength, 
  13:libs/dynamixel/dynamixel.c **** 	volatile uint8_t* recv_buffer,
  14:libs/dynamixel/dynamixel.c **** 	volatile uint8_t* recv_buffer_index
  15:libs/dynamixel/dynamixel.c **** );
  16:libs/dynamixel/dynamixel.c **** 
  17:libs/dynamixel/dynamixel.c **** // AX-12 Specific
  18:libs/dynamixel/dynamixel.c **** static volatile uint8_t ax_buffer[DYNAMIXEL_PACKET_SIZE];
  19:libs/dynamixel/dynamixel.c **** static volatile uint8_t ax_buffer_index = 0;
  20:libs/dynamixel/dynamixel.c **** static void ax_settx(void);
  21:libs/dynamixel/dynamixel.c **** static void ax_setrx(void);
  22:libs/dynamixel/dynamixel.c **** static void ax_write(uint8_t c);
  23:libs/dynamixel/dynamixel.c **** 
  24:libs/dynamixel/dynamixel.c **** // RX-24 Specific
  25:libs/dynamixel/dynamixel.c **** static volatile uint8_t rx_buffer[DYNAMIXEL_PACKET_SIZE];
  26:libs/dynamixel/dynamixel.c **** static volatile uint8_t rx_buffer_index = 0;
  27:libs/dynamixel/dynamixel.c **** static void rx_write(uint8_t c);
  28:libs/dynamixel/dynamixel.c **** 
  29:libs/dynamixel/dynamixel.c **** 
  30:libs/dynamixel/dynamixel.c **** ISR(USART0_RX_vect) {
  31:libs/dynamixel/dynamixel.c **** 	uint8_t data = UDR0;
  32:libs/dynamixel/dynamixel.c **** 	
  33:libs/dynamixel/dynamixel.c **** 	ax_buffer[ax_buffer_index] = data;
  34:libs/dynamixel/dynamixel.c **** 	if (ax_buffer_index < DYNAMIXEL_PACKET_SIZE - 1) {
  35:libs/dynamixel/dynamixel.c **** 		ax_buffer_index++;
  36:libs/dynamixel/dynamixel.c **** 	}
  37:libs/dynamixel/dynamixel.c **** 	
  38:libs/dynamixel/dynamixel.c **** 	// Ignore garbage
  39:libs/dynamixel/dynamixel.c **** 	if (ax_buffer_index == 1 && ax_buffer[0] != 0xFF) {
  40:libs/dynamixel/dynamixel.c **** 		ax_buffer_index = 0;
  41:libs/dynamixel/dynamixel.c **** 	}
  42:libs/dynamixel/dynamixel.c **** 	if (ax_buffer_index == 3 && 
  43:libs/dynamixel/dynamixel.c **** 		ax_buffer[0] == 0xFF && 
  44:libs/dynamixel/dynamixel.c **** 		ax_buffer[1] == 0xFF && 
  45:libs/dynamixel/dynamixel.c **** 		ax_buffer[2] == 0xFF) {
  46:libs/dynamixel/dynamixel.c **** 		ax_buffer_index = 2;
  47:libs/dynamixel/dynamixel.c **** 	}
  48:libs/dynamixel/dynamixel.c **** }
  49:libs/dynamixel/dynamixel.c **** 
  50:libs/dynamixel/dynamixel.c **** ISR(USART1_RX_vect) {
  51:libs/dynamixel/dynamixel.c **** 	rx_buffer[rx_buffer_index] = UDR1;
  52:libs/dynamixel/dynamixel.c **** 	if (rx_buffer_index < DYNAMIXEL_PACKET_SIZE - 1) {
  53:libs/dynamixel/dynamixel.c **** 		rx_buffer_index++;
  54:libs/dynamixel/dynamixel.c **** 	}
  55:libs/dynamixel/dynamixel.c **** 	
  56:libs/dynamixel/dynamixel.c **** 	// Ignore garbage
  57:libs/dynamixel/dynamixel.c **** 	if (rx_buffer_index == 1 && rx_buffer[0] != 0xFF) {
  58:libs/dynamixel/dynamixel.c **** 		rx_buffer_index = 0;
  59:libs/dynamixel/dynamixel.c **** 	}
  60:libs/dynamixel/dynamixel.c **** }
  61:libs/dynamixel/dynamixel.c **** 
  62:libs/dynamixel/dynamixel.c **** void dynamixel_ax_init(void) {
  63:libs/dynamixel/dynamixel.c **** 	// Set UART baudrate
  64:libs/dynamixel/dynamixel.c **** 	UBRR0H = ((F_CPU / 8 + DYNAMIXEL_BAUDRATE / 2) / DYNAMIXEL_BAUDRATE - 1) >> 8;
  65:libs/dynamixel/dynamixel.c **** 	UBRR0L = ((F_CPU / 8 + DYNAMIXEL_BAUDRATE / 2) / DYNAMIXEL_BAUDRATE - 1);
  66:libs/dynamixel/dynamixel.c **** 	UCSR0A |= (1 << U2X0);
  67:libs/dynamixel/dynamixel.c **** 	
  68:libs/dynamixel/dynamixel.c **** 	// Enable receiver and transmitter 
  69:libs/dynamixel/dynamixel.c **** 	UCSR0B |= (1 << TXEN0);
  70:libs/dynamixel/dynamixel.c **** 	UCSR0B |= (1 << RXEN0);
  71:libs/dynamixel/dynamixel.c **** 	UCSR0B |= (1 << RXCIE0);
  72:libs/dynamixel/dynamixel.c **** 	
  73:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE0);
  74:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE1);
  75:libs/dynamixel/dynamixel.c **** 	
  76:libs/dynamixel/dynamixel.c **** 	// Reset rx index
  77:libs/dynamixel/dynamixel.c **** 	ax_buffer_index = 0;
  78:libs/dynamixel/dynamixel.c **** }
  79:libs/dynamixel/dynamixel.c **** 
  80:libs/dynamixel/dynamixel.c **** void dynamixel_rx_init(void) {
  81:libs/dynamixel/dynamixel.c **** 	// Set UART baudrate
  82:libs/dynamixel/dynamixel.c **** 	UBRR1H = ((F_CPU / 8 + DYNAMIXEL_BAUDRATE / 2) / DYNAMIXEL_BAUDRATE - 1) >> 8;
  83:libs/dynamixel/dynamixel.c **** 	UBRR1L = ((F_CPU / 8 + DYNAMIXEL_BAUDRATE / 2) / DYNAMIXEL_BAUDRATE - 1);
  84:libs/dynamixel/dynamixel.c **** 	UCSR1A |= (1 << U2X1);
  85:libs/dynamixel/dynamixel.c **** 	
  86:libs/dynamixel/dynamixel.c **** 	// Enable receiver and transmitter 
  87:libs/dynamixel/dynamixel.c **** 	UCSR1B |= (1 << TXEN1);
  88:libs/dynamixel/dynamixel.c **** 	UCSR1B |= (1 << RXEN1);
  89:libs/dynamixel/dynamixel.c **** 	UCSR1B |= (1 << RXCIE1);
  90:libs/dynamixel/dynamixel.c **** 	
  91:libs/dynamixel/dynamixel.c **** 	DDRD |= (1 << PD2);
  92:libs/dynamixel/dynamixel.c **** 	DDRD |= (1 << PD3);
  93:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE2);
  94:libs/dynamixel/dynamixel.c **** 	
  95:libs/dynamixel/dynamixel.c **** 	PORTE |= (1 << PE2);
  96:libs/dynamixel/dynamixel.c **** 	// Reset rx index
  97:libs/dynamixel/dynamixel.c **** 	rx_buffer_index = 0;
  98:libs/dynamixel/dynamixel.c **** }
  99:libs/dynamixel/dynamixel.c **** 
 100:libs/dynamixel/dynamixel.c **** void ax_settx(void) {
 101:libs/dynamixel/dynamixel.c **** 	UCSR0B &= ~(1 << RXEN0);	// Disable RX
 102:libs/dynamixel/dynamixel.c **** 	
 103:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE1);			// Set TX as output
 104:libs/dynamixel/dynamixel.c **** 	DDRE &= ~(1 << PE0);		// Set RX as input
 105:libs/dynamixel/dynamixel.c **** 	
 106:libs/dynamixel/dynamixel.c **** 	UCSR0B |= (1 << TXEN0);		// Enable TX
 107:libs/dynamixel/dynamixel.c **** 		
 108:libs/dynamixel/dynamixel.c **** 	//UCSR0B &= ~(1 << RXCIE0);	// Disable RX interrupt
 109:libs/dynamixel/dynamixel.c **** }
 110:libs/dynamixel/dynamixel.c **** 
 111:libs/dynamixel/dynamixel.c **** 
 112:libs/dynamixel/dynamixel.c **** void ax_setrx(void) {	
 113:libs/dynamixel/dynamixel.c **** 	// Wait for TX complete flag before turning the bus around
 114:libs/dynamixel/dynamixel.c **** 	while(bit_is_clear(UCSR0A, TXC0));
 115:libs/dynamixel/dynamixel.c **** 	
 116:libs/dynamixel/dynamixel.c **** 	ax_buffer_index = 0;		// Reset RX index
 117:libs/dynamixel/dynamixel.c **** 	
 118:libs/dynamixel/dynamixel.c **** 	DDRE &= ~(1 << PE1);		// Set TX as input!
 119:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE0);			// Set RX as output
 120:libs/dynamixel/dynamixel.c **** 	
 121:libs/dynamixel/dynamixel.c **** 	UCSR0B &= ~(1 << TXEN0);	// Disable TX
 122:libs/dynamixel/dynamixel.c **** 	//UCSR0B |= (1 << RXCIE0);	// Enable RX interrupt
 123:libs/dynamixel/dynamixel.c **** 	UCSR0B |= (1 << RXEN0);		// Enable RX	
 124:libs/dynamixel/dynamixel.c **** }
 125:libs/dynamixel/dynamixel.c **** 
 126:libs/dynamixel/dynamixel.c **** void ax_write(uint8_t c) {
 127:libs/dynamixel/dynamixel.c **** 	while(bit_is_clear(UCSR0A, UDRE0));
 128:libs/dynamixel/dynamixel.c **** 	UDR0 = c;
 129:libs/dynamixel/dynamixel.c **** }
 130:libs/dynamixel/dynamixel.c **** 
 131:libs/dynamixel/dynamixel.c **** void rx_setrx(void) {
 132:libs/dynamixel/dynamixel.c **** 	while(bit_is_clear(UCSR1A, TXC1));
 133:libs/dynamixel/dynamixel.c **** 	// PORTE &= ~(1 << PE2);
 134:libs/dynamixel/dynamixel.c **** 	rx_buffer_index = 0;
 135:libs/dynamixel/dynamixel.c **** }
 136:libs/dynamixel/dynamixel.c **** 
 137:libs/dynamixel/dynamixel.c **** void rx_settx(void) {
 138:libs/dynamixel/dynamixel.c **** 	//while(bit_is_clear(UCSR1A, TXC1));
 139:libs/dynamixel/dynamixel.c **** 	PORTE |= (1 << PE2);
 140:libs/dynamixel/dynamixel.c **** }
 141:libs/dynamixel/dynamixel.c **** 
 142:libs/dynamixel/dynamixel.c **** void rx_write(uint8_t c) {
 143:libs/dynamixel/dynamixel.c **** 	while(bit_is_clear(UCSR1A, UDRE1));
 144:libs/dynamixel/dynamixel.c **** 	UDR1 = c;
 145:libs/dynamixel/dynamixel.c **** }
 146:libs/dynamixel/dynamixel.c **** 
 147:libs/dynamixel/dynamixel.c **** uint8_t calculatechecksum(volatile uint8_t* packet) {
  15               		.loc 1 147 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 FC01      		movw r30,r24
  23               	.LVL1:
  24               	.LBB4:
 148:libs/dynamixel/dynamixel.c **** 	uint16_t checksum = 0;
 149:libs/dynamixel/dynamixel.c **** 	
 150:libs/dynamixel/dynamixel.c **** 	for(uint8_t i = DYNAMIXEL_ID; i <= (packet[DYNAMIXEL_LENGTH] + 2); i++) {
  25               		.loc 1 150 0
  26 0002 92E0      		ldi r25,lo8(2)
  27               	.LBE4:
 148:libs/dynamixel/dynamixel.c **** 	uint16_t checksum = 0;
  28               		.loc 1 148 0
  29 0004 60E0      		ldi r22,0
  30 0006 70E0      		ldi r23,0
  31               	.LVL2:
  32               	.L2:
  33               	.LBB5:
  34               		.loc 1 150 0 discriminator 1
  35 0008 2381      		ldd r18,Z+3
  36 000a 492F      		mov r20,r25
  37 000c 50E0      		ldi r21,0
  38 000e 30E0      		ldi r19,0
  39 0010 2E5F      		subi r18,-2
  40 0012 3F4F      		sbci r19,-1
  41 0014 2417      		cp r18,r20
  42 0016 3507      		cpc r19,r21
  43 0018 04F0      		brlt .L5
 151:libs/dynamixel/dynamixel.c **** 		checksum += packet[i];
  44               		.loc 1 151 0 discriminator 3
  45 001a DF01      		movw r26,r30
  46 001c A40F      		add r26,r20
  47 001e B51F      		adc r27,r21
  48 0020 8C91      		ld r24,X
  49 0022 680F      		add r22,r24
  50 0024 711D      		adc r23,__zero_reg__
  51               	.LVL3:
 150:libs/dynamixel/dynamixel.c **** 		checksum += packet[i];
  52               		.loc 1 150 0 discriminator 3
  53 0026 9F5F      		subi r25,lo8(-(1))
  54               	.LVL4:
  55 0028 00C0      		rjmp .L2
  56               	.LVL5:
  57               	.L5:
  58               	.LBE5:
 152:libs/dynamixel/dynamixel.c **** 	}
 153:libs/dynamixel/dynamixel.c **** 	
 154:libs/dynamixel/dynamixel.c **** 	return ~(checksum % 256);
 155:libs/dynamixel/dynamixel.c **** }
  59               		.loc 1 155 0
  60 002a 862F      		mov r24,r22
  61 002c 8095      		com r24
  62 002e 0895      		ret
  63               		.cfi_endproc
  64               	.LFE17:
  67               	readpacket:
  68               	.LFB18:
 156:libs/dynamixel/dynamixel.c **** 
 157:libs/dynamixel/dynamixel.c **** uint8_t readpacket(
 158:libs/dynamixel/dynamixel.c **** 	volatile uint8_t* rxpacket, 
 159:libs/dynamixel/dynamixel.c **** 	uint8_t packetlength, 
 160:libs/dynamixel/dynamixel.c **** 	volatile uint8_t* recv_buffer,
 161:libs/dynamixel/dynamixel.c **** 	volatile uint8_t* recv_buffer_index
 162:libs/dynamixel/dynamixel.c **** 	) {
  69               		.loc 1 162 0
  70               		.cfi_startproc
  71               	.LVL6:
  72 0030 CF93      		push r28
  73               	.LCFI0:
  74               		.cfi_def_cfa_offset 3
  75               		.cfi_offset 28, -2
  76 0032 DF93      		push r29
  77               	.LCFI1:
  78               		.cfi_def_cfa_offset 4
  79               		.cfi_offset 29, -3
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 2 */
  83               	.L__stack_usage = 2
  84 0034 D901      		movw r26,r18
  85               	.LVL7:
 163:libs/dynamixel/dynamixel.c **** 		
 164:libs/dynamixel/dynamixel.c **** 	uint16_t ulcounter = 0;
 165:libs/dynamixel/dynamixel.c **** 	size_t i;
 166:libs/dynamixel/dynamixel.c **** 
 167:libs/dynamixel/dynamixel.c **** 	while(*recv_buffer_index < packetlength) {
  86               		.loc 1 167 0
  87 0036 EEED      		ldi r30,lo8(-34)
  88 0038 F5E0      		ldi r31,lo8(5)
  89               	.LVL8:
  90               	.L7:
  91 003a 3C91      		ld r19,X
  92 003c 3617      		cp r19,r22
  93 003e 00F4      		brsh .L15
  94               	.LVL9:
  95 0040 3197      		sbiw r30,1
  96               	.LVL10:
 168:libs/dynamixel/dynamixel.c **** 		if(ulcounter++ > (DYNAMIXEL_TIMEOUT_MS) * 10) {
  97               		.loc 1 168 0
  98 0042 01F0      		breq .L14
  99               	.LVL11:
 100               	.LBB6:
 101               	.LBB7:
 102               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 103               		.loc 2 245 0
 104 0044 CFE8      		ldi r28,lo8(399)
 105 0046 D1E0      		ldi r29,hi8(399)
 106 0048 2197      	1:	sbiw r28,1
 107 004a 01F4      		brne 1b
 108 004c 00C0      		rjmp .
 109 004e 0000      		nop
 110 0050 00C0      		rjmp .L7
 111               	.LVL12:
 112               	.L15:
 113               	.LBE7:
 114               	.LBE6:
 115 0052 20E0      		ldi r18,0
 116 0054 30E0      		ldi r19,0
 117               	.LVL13:
 169:libs/dynamixel/dynamixel.c **** 			return DYNAMIXEL_RX_TIMEOUT;
 170:libs/dynamixel/dynamixel.c **** 		}
 171:libs/dynamixel/dynamixel.c **** 		_delay_us(100);
 172:libs/dynamixel/dynamixel.c **** 	}
 173:libs/dynamixel/dynamixel.c **** 
 174:libs/dynamixel/dynamixel.c **** 	// Copy received packet to `rxpacket`
 175:libs/dynamixel/dynamixel.c **** 	for (i = 0; i < packetlength; i++) {
 118               		.loc 1 175 0
 119 0056 70E0      		ldi r23,0
 120               	.LVL14:
 121               	.L10:
 122 0058 FC01      		movw r30,r24
 123               		.loc 1 175 0 is_stmt 0 discriminator 1
 124 005a 2617      		cp r18,r22
 125 005c 3707      		cpc r19,r23
 126 005e 00F4      		brsh .L16
 127 0060 E20F      		add r30,r18
 128 0062 F31F      		adc r31,r19
 129 0064 DA01      		movw r26,r20
 130 0066 A20F      		add r26,r18
 131 0068 B31F      		adc r27,r19
 176:libs/dynamixel/dynamixel.c **** 		rxpacket[i] = recv_buffer[i];
 132               		.loc 1 176 0 is_stmt 1 discriminator 3
 133 006a AC91      		ld r26,X
 134 006c A083      		st Z,r26
 175:libs/dynamixel/dynamixel.c **** 		rxpacket[i] = recv_buffer[i];
 135               		.loc 1 175 0 discriminator 3
 136 006e 2F5F      		subi r18,-1
 137 0070 3F4F      		sbci r19,-1
 138               	.LVL15:
 139 0072 00C0      		rjmp .L10
 140               	.L16:
 177:libs/dynamixel/dynamixel.c **** 	}
 178:libs/dynamixel/dynamixel.c **** 
 179:libs/dynamixel/dynamixel.c **** 	// Check if packet is corrupted
 180:libs/dynamixel/dynamixel.c **** 	if((rxpacket[0] != 255) || (rxpacket[1] != 255)) {
 141               		.loc 1 180 0
 142 0074 2081      		ld r18,Z
 143               	.LVL16:
 144 0076 2F3F      		cpi r18,lo8(-1)
 145 0078 01F0      		breq .L12
 146               	.LVL17:
 147               	.L13:
 181:libs/dynamixel/dynamixel.c **** 		return DYNAMIXEL_RX_CORRUPT;
 148               		.loc 1 181 0
 149 007a 82E0      		ldi r24,lo8(2)
 150 007c 00C0      		rjmp .L8
 151               	.LVL18:
 152               	.L12:
 180:libs/dynamixel/dynamixel.c **** 		return DYNAMIXEL_RX_CORRUPT;
 153               		.loc 1 180 0 discriminator 1
 154 007e 2181      		ldd r18,Z+1
 155 0080 2F3F      		cpi r18,lo8(-1)
 156 0082 01F4      		brne .L13
 182:libs/dynamixel/dynamixel.c **** 	}
 183:libs/dynamixel/dynamixel.c **** 		
 184:libs/dynamixel/dynamixel.c **** 	if(rxpacket[packetlength - 1] != calculatechecksum(rxpacket)) {
 157               		.loc 1 184 0
 158 0084 6150      		subi r22,1
 159 0086 7109      		sbc r23,__zero_reg__
 160               	.LVL19:
 161 0088 FC01      		movw r30,r24
 162 008a E60F      		add r30,r22
 163 008c F71F      		adc r31,r23
 164 008e C081      		ld r28,Z
 165 0090 0E94 0000 		call calculatechecksum
 166               	.LVL20:
 167 0094 C813      		cpse r28,r24
 168 0096 00C0      		rjmp .L13
 185:libs/dynamixel/dynamixel.c **** 		return DYNAMIXEL_RX_CORRUPT;
 186:libs/dynamixel/dynamixel.c **** 	}
 187:libs/dynamixel/dynamixel.c **** 	
 188:libs/dynamixel/dynamixel.c **** 	return DYNAMIXEL_SUCCESS;
 169               		.loc 1 188 0
 170 0098 81E0      		ldi r24,lo8(1)
 171 009a 00C0      		rjmp .L8
 172               	.LVL21:
 173               	.L14:
 169:libs/dynamixel/dynamixel.c **** 		}
 174               		.loc 1 169 0
 175 009c 83E0      		ldi r24,lo8(3)
 176               	.LVL22:
 177               	.L8:
 178               	/* epilogue start */
 189:libs/dynamixel/dynamixel.c **** }
 179               		.loc 1 189 0
 180 009e DF91      		pop r29
 181 00a0 CF91      		pop r28
 182 00a2 0895      		ret
 183               		.cfi_endproc
 184               	.LFE18:
 186               	.global	__vector_21
 188               	__vector_21:
 189               	.LFB7:
  30:libs/dynamixel/dynamixel.c **** 	uint8_t data = UDR0;
 190               		.loc 1 30 0
 191               		.cfi_startproc
 192 00a4 1F92      		push r1
 193               	.LCFI2:
 194               		.cfi_def_cfa_offset 3
 195               		.cfi_offset 1, -2
 196 00a6 0F92      		push r0
 197               	.LCFI3:
 198               		.cfi_def_cfa_offset 4
 199               		.cfi_offset 0, -3
 200 00a8 0FB6      		in r0,__SREG__
 201 00aa 0F92      		push r0
 202 00ac 1124      		clr __zero_reg__
 203 00ae 0BB6      		in r0,__RAMPZ__
 204 00b0 0F92      		push r0
 205 00b2 8F93      		push r24
 206               	.LCFI4:
 207               		.cfi_def_cfa_offset 5
 208               		.cfi_offset 24, -4
 209 00b4 EF93      		push r30
 210               	.LCFI5:
 211               		.cfi_def_cfa_offset 6
 212               		.cfi_offset 30, -5
 213 00b6 FF93      		push r31
 214               	.LCFI6:
 215               		.cfi_def_cfa_offset 7
 216               		.cfi_offset 31, -6
 217               	/* prologue: Signal */
 218               	/* frame size = 0 */
 219               	/* stack size = 7 */
 220               	.L__stack_usage = 7
  31:libs/dynamixel/dynamixel.c **** 	
 221               		.loc 1 31 0
 222 00b8 8091 C600 		lds r24,198
 223               	.LVL23:
  33:libs/dynamixel/dynamixel.c **** 	if (ax_buffer_index < DYNAMIXEL_PACKET_SIZE - 1) {
 224               		.loc 1 33 0
 225 00bc E091 0000 		lds r30,ax_buffer_index
 226 00c0 F0E0      		ldi r31,0
 227 00c2 E050      		subi r30,lo8(-(ax_buffer))
 228 00c4 F040      		sbci r31,hi8(-(ax_buffer))
 229 00c6 8083      		st Z,r24
  34:libs/dynamixel/dynamixel.c **** 		ax_buffer_index++;
 230               		.loc 1 34 0
 231 00c8 8091 0000 		lds r24,ax_buffer_index
 232               	.LVL24:
 233 00cc 8F3F      		cpi r24,lo8(-1)
 234 00ce 01F0      		breq .L18
  35:libs/dynamixel/dynamixel.c **** 	}
 235               		.loc 1 35 0
 236 00d0 8091 0000 		lds r24,ax_buffer_index
 237 00d4 8F5F      		subi r24,lo8(-(1))
 238 00d6 8093 0000 		sts ax_buffer_index,r24
 239               	.LVL25:
 240               	.L18:
  39:libs/dynamixel/dynamixel.c **** 		ax_buffer_index = 0;
 241               		.loc 1 39 0
 242 00da 8091 0000 		lds r24,ax_buffer_index
 243 00de 8130      		cpi r24,lo8(1)
 244 00e0 01F4      		brne .L19
  39:libs/dynamixel/dynamixel.c **** 		ax_buffer_index = 0;
 245               		.loc 1 39 0 is_stmt 0 discriminator 1
 246 00e2 8091 0000 		lds r24,ax_buffer
 247 00e6 8F3F      		cpi r24,lo8(-1)
 248 00e8 01F0      		breq .L19
  40:libs/dynamixel/dynamixel.c **** 	}
 249               		.loc 1 40 0 is_stmt 1
 250 00ea 1092 0000 		sts ax_buffer_index,__zero_reg__
 251               	.L19:
  42:libs/dynamixel/dynamixel.c **** 		ax_buffer[0] == 0xFF && 
 252               		.loc 1 42 0
 253 00ee 8091 0000 		lds r24,ax_buffer_index
 254 00f2 8330      		cpi r24,lo8(3)
 255 00f4 01F4      		brne .L17
  43:libs/dynamixel/dynamixel.c **** 		ax_buffer[1] == 0xFF && 
 256               		.loc 1 43 0 discriminator 1
 257 00f6 8091 0000 		lds r24,ax_buffer
  42:libs/dynamixel/dynamixel.c **** 		ax_buffer[0] == 0xFF && 
 258               		.loc 1 42 0 discriminator 1
 259 00fa 8F3F      		cpi r24,lo8(-1)
 260 00fc 01F4      		brne .L17
  44:libs/dynamixel/dynamixel.c **** 		ax_buffer[2] == 0xFF) {
 261               		.loc 1 44 0
 262 00fe 8091 0000 		lds r24,ax_buffer+1
  43:libs/dynamixel/dynamixel.c **** 		ax_buffer[1] == 0xFF && 
 263               		.loc 1 43 0
 264 0102 8F3F      		cpi r24,lo8(-1)
 265 0104 01F4      		brne .L17
  45:libs/dynamixel/dynamixel.c **** 		ax_buffer_index = 2;
 266               		.loc 1 45 0
 267 0106 8091 0000 		lds r24,ax_buffer+2
  44:libs/dynamixel/dynamixel.c **** 		ax_buffer[2] == 0xFF) {
 268               		.loc 1 44 0
 269 010a 8F3F      		cpi r24,lo8(-1)
 270 010c 01F4      		brne .L17
  46:libs/dynamixel/dynamixel.c **** 	}
 271               		.loc 1 46 0
 272 010e 82E0      		ldi r24,lo8(2)
 273 0110 8093 0000 		sts ax_buffer_index,r24
 274               	.L17:
 275               	/* epilogue start */
  48:libs/dynamixel/dynamixel.c **** 
 276               		.loc 1 48 0
 277 0114 FF91      		pop r31
 278 0116 EF91      		pop r30
 279 0118 8F91      		pop r24
 280 011a 0F90      		pop r0
 281 011c 0BBE      		out __RAMPZ__,r0
 282 011e 0F90      		pop r0
 283 0120 0FBE      		out __SREG__,r0
 284 0122 0F90      		pop r0
 285 0124 1F90      		pop r1
 286 0126 1895      		reti
 287               		.cfi_endproc
 288               	.LFE7:
 290               	.global	__vector_32
 292               	__vector_32:
 293               	.LFB8:
  50:libs/dynamixel/dynamixel.c **** 	rx_buffer[rx_buffer_index] = UDR1;
 294               		.loc 1 50 0
 295               		.cfi_startproc
 296 0128 1F92      		push r1
 297               	.LCFI7:
 298               		.cfi_def_cfa_offset 3
 299               		.cfi_offset 1, -2
 300 012a 0F92      		push r0
 301               	.LCFI8:
 302               		.cfi_def_cfa_offset 4
 303               		.cfi_offset 0, -3
 304 012c 0FB6      		in r0,__SREG__
 305 012e 0F92      		push r0
 306 0130 1124      		clr __zero_reg__
 307 0132 0BB6      		in r0,__RAMPZ__
 308 0134 0F92      		push r0
 309 0136 8F93      		push r24
 310               	.LCFI9:
 311               		.cfi_def_cfa_offset 5
 312               		.cfi_offset 24, -4
 313 0138 EF93      		push r30
 314               	.LCFI10:
 315               		.cfi_def_cfa_offset 6
 316               		.cfi_offset 30, -5
 317 013a FF93      		push r31
 318               	.LCFI11:
 319               		.cfi_def_cfa_offset 7
 320               		.cfi_offset 31, -6
 321               	/* prologue: Signal */
 322               	/* frame size = 0 */
 323               	/* stack size = 7 */
 324               	.L__stack_usage = 7
  51:libs/dynamixel/dynamixel.c **** 	if (rx_buffer_index < DYNAMIXEL_PACKET_SIZE - 1) {
 325               		.loc 1 51 0
 326 013c E091 0000 		lds r30,rx_buffer_index
 327 0140 F0E0      		ldi r31,0
 328 0142 8091 CE00 		lds r24,206
 329 0146 E050      		subi r30,lo8(-(rx_buffer))
 330 0148 F040      		sbci r31,hi8(-(rx_buffer))
 331 014a 8083      		st Z,r24
  52:libs/dynamixel/dynamixel.c **** 		rx_buffer_index++;
 332               		.loc 1 52 0
 333 014c 8091 0000 		lds r24,rx_buffer_index
 334 0150 8F3F      		cpi r24,lo8(-1)
 335 0152 01F0      		breq .L28
  53:libs/dynamixel/dynamixel.c **** 	}
 336               		.loc 1 53 0
 337 0154 8091 0000 		lds r24,rx_buffer_index
 338 0158 8F5F      		subi r24,lo8(-(1))
 339 015a 8093 0000 		sts rx_buffer_index,r24
 340               	.L28:
  57:libs/dynamixel/dynamixel.c **** 		rx_buffer_index = 0;
 341               		.loc 1 57 0
 342 015e 8091 0000 		lds r24,rx_buffer_index
 343 0162 8130      		cpi r24,lo8(1)
 344 0164 01F4      		brne .L27
  57:libs/dynamixel/dynamixel.c **** 		rx_buffer_index = 0;
 345               		.loc 1 57 0 is_stmt 0 discriminator 1
 346 0166 8091 0000 		lds r24,rx_buffer
 347 016a 8F3F      		cpi r24,lo8(-1)
 348 016c 01F0      		breq .L27
  58:libs/dynamixel/dynamixel.c **** 	}
 349               		.loc 1 58 0 is_stmt 1
 350 016e 1092 0000 		sts rx_buffer_index,__zero_reg__
 351               	.L27:
 352               	/* epilogue start */
  60:libs/dynamixel/dynamixel.c **** 
 353               		.loc 1 60 0
 354 0172 FF91      		pop r31
 355 0174 EF91      		pop r30
 356 0176 8F91      		pop r24
 357 0178 0F90      		pop r0
 358 017a 0BBE      		out __RAMPZ__,r0
 359 017c 0F90      		pop r0
 360 017e 0FBE      		out __SREG__,r0
 361 0180 0F90      		pop r0
 362 0182 1F90      		pop r1
 363 0184 1895      		reti
 364               		.cfi_endproc
 365               	.LFE8:
 367               	.global	dynamixel_ax_init
 369               	dynamixel_ax_init:
 370               	.LFB9:
  62:libs/dynamixel/dynamixel.c **** 	// Set UART baudrate
 371               		.loc 1 62 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
  64:libs/dynamixel/dynamixel.c **** 	UBRR0L = ((F_CPU / 8 + DYNAMIXEL_BAUDRATE / 2) / DYNAMIXEL_BAUDRATE - 1);
 377               		.loc 1 64 0
 378 0186 1092 C500 		sts 197,__zero_reg__
  65:libs/dynamixel/dynamixel.c **** 	UCSR0A |= (1 << U2X0);
 379               		.loc 1 65 0
 380 018a 82E2      		ldi r24,lo8(34)
 381 018c 8093 C400 		sts 196,r24
  66:libs/dynamixel/dynamixel.c **** 	
 382               		.loc 1 66 0
 383 0190 E0EC      		ldi r30,lo8(-64)
 384 0192 F0E0      		ldi r31,0
 385 0194 8081      		ld r24,Z
 386 0196 8260      		ori r24,lo8(2)
 387 0198 8083      		st Z,r24
  69:libs/dynamixel/dynamixel.c **** 	UCSR0B |= (1 << RXEN0);
 388               		.loc 1 69 0
 389 019a E1EC      		ldi r30,lo8(-63)
 390 019c F0E0      		ldi r31,0
 391 019e 8081      		ld r24,Z
 392 01a0 8860      		ori r24,lo8(8)
 393 01a2 8083      		st Z,r24
  70:libs/dynamixel/dynamixel.c **** 	UCSR0B |= (1 << RXCIE0);
 394               		.loc 1 70 0
 395 01a4 8081      		ld r24,Z
 396 01a6 8061      		ori r24,lo8(16)
 397 01a8 8083      		st Z,r24
  71:libs/dynamixel/dynamixel.c **** 	
 398               		.loc 1 71 0
 399 01aa 8081      		ld r24,Z
 400 01ac 8068      		ori r24,lo8(-128)
 401 01ae 8083      		st Z,r24
  73:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE1);
 402               		.loc 1 73 0
 403 01b0 689A      		sbi 0xd,0
  74:libs/dynamixel/dynamixel.c **** 	
 404               		.loc 1 74 0
 405 01b2 699A      		sbi 0xd,1
  77:libs/dynamixel/dynamixel.c **** }
 406               		.loc 1 77 0
 407 01b4 1092 0000 		sts ax_buffer_index,__zero_reg__
 408 01b8 0895      		ret
 409               		.cfi_endproc
 410               	.LFE9:
 412               	.global	dynamixel_rx_init
 414               	dynamixel_rx_init:
 415               	.LFB10:
  80:libs/dynamixel/dynamixel.c **** 	// Set UART baudrate
 416               		.loc 1 80 0
 417               		.cfi_startproc
 418               	/* prologue: function */
 419               	/* frame size = 0 */
 420               	/* stack size = 0 */
 421               	.L__stack_usage = 0
  82:libs/dynamixel/dynamixel.c **** 	UBRR1L = ((F_CPU / 8 + DYNAMIXEL_BAUDRATE / 2) / DYNAMIXEL_BAUDRATE - 1);
 422               		.loc 1 82 0
 423 01ba 1092 CD00 		sts 205,__zero_reg__
  83:libs/dynamixel/dynamixel.c **** 	UCSR1A |= (1 << U2X1);
 424               		.loc 1 83 0
 425 01be 82E2      		ldi r24,lo8(34)
 426 01c0 8093 CC00 		sts 204,r24
  84:libs/dynamixel/dynamixel.c **** 	
 427               		.loc 1 84 0
 428 01c4 E8EC      		ldi r30,lo8(-56)
 429 01c6 F0E0      		ldi r31,0
 430 01c8 8081      		ld r24,Z
 431 01ca 8260      		ori r24,lo8(2)
 432 01cc 8083      		st Z,r24
  87:libs/dynamixel/dynamixel.c **** 	UCSR1B |= (1 << RXEN1);
 433               		.loc 1 87 0
 434 01ce E9EC      		ldi r30,lo8(-55)
 435 01d0 F0E0      		ldi r31,0
 436 01d2 8081      		ld r24,Z
 437 01d4 8860      		ori r24,lo8(8)
 438 01d6 8083      		st Z,r24
  88:libs/dynamixel/dynamixel.c **** 	UCSR1B |= (1 << RXCIE1);
 439               		.loc 1 88 0
 440 01d8 8081      		ld r24,Z
 441 01da 8061      		ori r24,lo8(16)
 442 01dc 8083      		st Z,r24
  89:libs/dynamixel/dynamixel.c **** 	
 443               		.loc 1 89 0
 444 01de 8081      		ld r24,Z
 445 01e0 8068      		ori r24,lo8(-128)
 446 01e2 8083      		st Z,r24
  91:libs/dynamixel/dynamixel.c **** 	DDRD |= (1 << PD3);
 447               		.loc 1 91 0
 448 01e4 529A      		sbi 0xa,2
  92:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE2);
 449               		.loc 1 92 0
 450 01e6 539A      		sbi 0xa,3
  93:libs/dynamixel/dynamixel.c **** 	
 451               		.loc 1 93 0
 452 01e8 6A9A      		sbi 0xd,2
  95:libs/dynamixel/dynamixel.c **** 	// Reset rx index
 453               		.loc 1 95 0
 454 01ea 729A      		sbi 0xe,2
  97:libs/dynamixel/dynamixel.c **** }
 455               		.loc 1 97 0
 456 01ec 1092 0000 		sts rx_buffer_index,__zero_reg__
 457 01f0 0895      		ret
 458               		.cfi_endproc
 459               	.LFE10:
 461               	.global	rx_setrx
 463               	rx_setrx:
 464               	.LFB14:
 131:libs/dynamixel/dynamixel.c **** 	while(bit_is_clear(UCSR1A, TXC1));
 465               		.loc 1 131 0
 466               		.cfi_startproc
 467               	/* prologue: function */
 468               	/* frame size = 0 */
 469               	/* stack size = 0 */
 470               	.L__stack_usage = 0
 471               	.L39:
 132:libs/dynamixel/dynamixel.c **** 	// PORTE &= ~(1 << PE2);
 472               		.loc 1 132 0 discriminator 1
 473 01f2 8091 C800 		lds r24,200
 474 01f6 86FF      		sbrs r24,6
 475 01f8 00C0      		rjmp .L39
 134:libs/dynamixel/dynamixel.c **** }
 476               		.loc 1 134 0
 477 01fa 1092 0000 		sts rx_buffer_index,__zero_reg__
 478 01fe 0895      		ret
 479               		.cfi_endproc
 480               	.LFE14:
 482               	.global	rx_settx
 484               	rx_settx:
 485               	.LFB15:
 137:libs/dynamixel/dynamixel.c **** 	//while(bit_is_clear(UCSR1A, TXC1));
 486               		.loc 1 137 0
 487               		.cfi_startproc
 488               	/* prologue: function */
 489               	/* frame size = 0 */
 490               	/* stack size = 0 */
 491               	.L__stack_usage = 0
 139:libs/dynamixel/dynamixel.c **** }
 492               		.loc 1 139 0
 493 0200 729A      		sbi 0xe,2
 494 0202 0895      		ret
 495               		.cfi_endproc
 496               	.LFE15:
 498               	.global	dynamixel_ax_txrx
 500               	dynamixel_ax_txrx:
 501               	.LFB19:
 190:libs/dynamixel/dynamixel.c **** 
 191:libs/dynamixel/dynamixel.c **** uint8_t dynamixel_ax_txrx(volatile uint8_t* txpacket, volatile uint8_t* rxpacket) {
 502               		.loc 1 191 0
 503               		.cfi_startproc
 504               	.LVL26:
 505 0204 DF92      		push r13
 506               	.LCFI12:
 507               		.cfi_def_cfa_offset 3
 508               		.cfi_offset 13, -2
 509 0206 EF92      		push r14
 510               	.LCFI13:
 511               		.cfi_def_cfa_offset 4
 512               		.cfi_offset 14, -3
 513 0208 FF92      		push r15
 514               	.LCFI14:
 515               		.cfi_def_cfa_offset 5
 516               		.cfi_offset 15, -4
 517 020a 0F93      		push r16
 518               	.LCFI15:
 519               		.cfi_def_cfa_offset 6
 520               		.cfi_offset 16, -5
 521 020c 1F93      		push r17
 522               	.LCFI16:
 523               		.cfi_def_cfa_offset 7
 524               		.cfi_offset 17, -6
 525 020e CF93      		push r28
 526               	.LCFI17:
 527               		.cfi_def_cfa_offset 8
 528               		.cfi_offset 28, -7
 529 0210 DF93      		push r29
 530               	.LCFI18:
 531               		.cfi_def_cfa_offset 9
 532               		.cfi_offset 29, -8
 533               	/* prologue: function */
 534               	/* frame size = 0 */
 535               	/* stack size = 7 */
 536               	.L__stack_usage = 7
 537 0212 EC01      		movw r28,r24
 538 0214 7B01      		movw r14,r22
 539               	.LVL27:
 192:libs/dynamixel/dynamixel.c **** 	uint8_t rxlength = 0;
 193:libs/dynamixel/dynamixel.c **** 	uint8_t txlength = txpacket[DYNAMIXEL_LENGTH] + 4;
 540               		.loc 1 193 0
 541 0216 8B81      		ldd r24,Y+3
 542               	.LVL28:
 543 0218 94E0      		ldi r25,lo8(4)
 544 021a D92E      		mov r13,r25
 545 021c D80E      		add r13,r24
 546               	.LVL29:
 194:libs/dynamixel/dynamixel.c **** 	uint8_t status = DYNAMIXEL_SUCCESS;
 195:libs/dynamixel/dynamixel.c **** 	
 196:libs/dynamixel/dynamixel.c **** 	txpacket[0] = (uint8_t) 0xff;
 547               		.loc 1 196 0
 548 021e 8FEF      		ldi r24,lo8(-1)
 549 0220 8883      		st Y,r24
 197:libs/dynamixel/dynamixel.c **** 	txpacket[1] = (uint8_t) 0xff;
 550               		.loc 1 197 0
 551 0222 8983      		std Y+1,r24
 198:libs/dynamixel/dynamixel.c **** 	txpacket[txlength - 1] = (uint8_t)calculatechecksum(txpacket);
 552               		.loc 1 198 0
 553 0224 0D2D      		mov r16,r13
 554 0226 10E0      		ldi r17,0
 555 0228 0150      		subi r16,1
 556 022a 1109      		sbc r17,__zero_reg__
 557 022c 0C0F      		add r16,r28
 558 022e 1D1F      		adc r17,r29
 559 0230 CE01      		movw r24,r28
 560 0232 0E94 0000 		call calculatechecksum
 561               	.LVL30:
 562 0236 F801      		movw r30,r16
 563 0238 8083      		st Z,r24
 564               	.LVL31:
 565 023a 1AE0      		ldi r17,lo8(10)
 566 023c 0C2F      		mov r16,r28
 567               	.LVL32:
 568               	.L52:
 569               	.LBB16:
 570               	.LBB17:
 571               	.LBB18:
 101:libs/dynamixel/dynamixel.c **** 	
 572               		.loc 1 101 0
 573 023e 8091 C100 		lds r24,193
 574 0242 8F7E      		andi r24,lo8(-17)
 575 0244 8093 C100 		sts 193,r24
 103:libs/dynamixel/dynamixel.c **** 	DDRE &= ~(1 << PE0);		// Set RX as input
 576               		.loc 1 103 0
 577 0248 699A      		sbi 0xd,1
 104:libs/dynamixel/dynamixel.c **** 	
 578               		.loc 1 104 0
 579 024a 6898      		cbi 0xd,0
 106:libs/dynamixel/dynamixel.c **** 		
 580               		.loc 1 106 0
 581 024c 8091 C100 		lds r24,193
 582 0250 8860      		ori r24,lo8(8)
 583 0252 8093 C100 		sts 193,r24
 584 0256 EC2F      		mov r30,r28
 585 0258 FD2F      		mov r31,r29
 586               	.L44:
 587               	.LVL33:
 588 025a 8E2F      		mov r24,r30
 589 025c 801B      		sub r24,r16
 590               	.LBE18:
 591               	.LBE17:
 592               	.LBB19:
 199:libs/dynamixel/dynamixel.c **** 	
 200:libs/dynamixel/dynamixel.c **** 	for (uint8_t i = 0; i < DYNAMIXEL_RETRY_COUNT; i++) {
 201:libs/dynamixel/dynamixel.c **** 		// Write packet	
 202:libs/dynamixel/dynamixel.c **** 		ax_settx();
 203:libs/dynamixel/dynamixel.c **** 		for(uint8_t i = 0; i < txlength; i++) {
 593               		.loc 1 203 0 discriminator 1
 594 025e 8D15      		cp r24,r13
 595 0260 00F4      		brsh .L59
 204:libs/dynamixel/dynamixel.c **** 			ax_write(txpacket[i]);
 596               		.loc 1 204 0 discriminator 3
 597 0262 8081      		ld r24,Z
 598               	.LVL34:
 599               	.L45:
 600               	.LBB20:
 601               	.LBB21:
 127:libs/dynamixel/dynamixel.c **** 	UDR0 = c;
 602               		.loc 1 127 0
 603 0264 9091 C000 		lds r25,192
 604 0268 95FF      		sbrs r25,5
 605 026a 00C0      		rjmp .L45
 128:libs/dynamixel/dynamixel.c **** }
 606               		.loc 1 128 0
 607 026c 8093 C600 		sts 198,r24
 608               	.LVL35:
 609 0270 3196      		adiw r30,1
 610               	.LVL36:
 611 0272 00C0      		rjmp .L44
 612               	.LVL37:
 613               	.L59:
 614               	.LBE21:
 615               	.LBE20:
 616               	.LBE19:
 617               	.LBB22:
 618               	.LBB23:
 114:libs/dynamixel/dynamixel.c **** 	
 619               		.loc 1 114 0
 620 0274 8091 C000 		lds r24,192
 621 0278 86FF      		sbrs r24,6
 622 027a 00C0      		rjmp .L59
 116:libs/dynamixel/dynamixel.c **** 	
 623               		.loc 1 116 0
 624 027c 1092 0000 		sts ax_buffer_index,__zero_reg__
 118:libs/dynamixel/dynamixel.c **** 	DDRE |= (1 << PE0);			// Set RX as output
 625               		.loc 1 118 0
 626 0280 6998      		cbi 0xd,1
 119:libs/dynamixel/dynamixel.c **** 	
 627               		.loc 1 119 0
 628 0282 689A      		sbi 0xd,0
 121:libs/dynamixel/dynamixel.c **** 	//UCSR0B |= (1 << RXCIE0);	// Enable RX interrupt
 629               		.loc 1 121 0
 630 0284 8091 C100 		lds r24,193
 631 0288 877F      		andi r24,lo8(-9)
 632 028a 8093 C100 		sts 193,r24
 123:libs/dynamixel/dynamixel.c **** }
 633               		.loc 1 123 0
 634 028e 8091 C100 		lds r24,193
 635 0292 8061      		ori r24,lo8(16)
 636 0294 8093 C100 		sts 193,r24
 637               	.LBE23:
 638               	.LBE22:
 205:libs/dynamixel/dynamixel.c **** 		}
 206:libs/dynamixel/dynamixel.c **** 		ax_setrx();
 207:libs/dynamixel/dynamixel.c **** 		
 208:libs/dynamixel/dynamixel.c **** 		
 209:libs/dynamixel/dynamixel.c **** 		// Read response
 210:libs/dynamixel/dynamixel.c **** 		if(txpacket[DYNAMIXEL_ID] != DYNAMIXEL_BROADCAST_ID) {	
 639               		.loc 1 210 0
 640 0298 8A81      		ldd r24,Y+2
 641 029a 8E3F      		cpi r24,lo8(-2)
 642 029c 01F4      		brne .L48
 643               	.LVL38:
 644               	.L51:
 211:libs/dynamixel/dynamixel.c **** 			if(txpacket[DYNAMIXEL_INSTRUCTION] == DYNAMIXEL_READ) {
 212:libs/dynamixel/dynamixel.c **** 				rxlength = txpacket[DYNAMIXEL_PARAMETER + 1] + 6;
 213:libs/dynamixel/dynamixel.c **** 			}
 214:libs/dynamixel/dynamixel.c **** 			else {
 215:libs/dynamixel/dynamixel.c **** 				rxlength = 6;
 216:libs/dynamixel/dynamixel.c **** 			}
 217:libs/dynamixel/dynamixel.c **** 			
 218:libs/dynamixel/dynamixel.c **** 			status = readpacket(rxpacket, rxlength, ax_buffer, &ax_buffer_index);
 219:libs/dynamixel/dynamixel.c **** 			if (status == DYNAMIXEL_SUCCESS) {
 220:libs/dynamixel/dynamixel.c **** 				return status;
 221:libs/dynamixel/dynamixel.c **** 			}
 222:libs/dynamixel/dynamixel.c **** 		} else {
 223:libs/dynamixel/dynamixel.c **** 			return DYNAMIXEL_SUCCESS;
 645               		.loc 1 223 0
 646 029e 81E0      		ldi r24,lo8(1)
 647 02a0 00C0      		rjmp .L49
 648               	.LVL39:
 649               	.L48:
 211:libs/dynamixel/dynamixel.c **** 			if(txpacket[DYNAMIXEL_INSTRUCTION] == DYNAMIXEL_READ) {
 650               		.loc 1 211 0
 651 02a2 8C81      		ldd r24,Y+4
 652 02a4 8230      		cpi r24,lo8(2)
 653 02a6 01F4      		brne .L53
 212:libs/dynamixel/dynamixel.c **** 			}
 654               		.loc 1 212 0
 655 02a8 6E81      		ldd r22,Y+6
 656 02aa 6A5F      		subi r22,lo8(-(6))
 657               	.LVL40:
 658 02ac 00C0      		rjmp .L50
 659               	.LVL41:
 660               	.L53:
 215:libs/dynamixel/dynamixel.c **** 			}
 661               		.loc 1 215 0
 662 02ae 66E0      		ldi r22,lo8(6)
 663               	.L50:
 664               	.LVL42:
 218:libs/dynamixel/dynamixel.c **** 			if (status == DYNAMIXEL_SUCCESS) {
 665               		.loc 1 218 0
 666 02b0 20E0      		ldi r18,lo8(ax_buffer_index)
 667 02b2 30E0      		ldi r19,hi8(ax_buffer_index)
 668 02b4 40E0      		ldi r20,lo8(ax_buffer)
 669 02b6 50E0      		ldi r21,hi8(ax_buffer)
 670 02b8 C701      		movw r24,r14
 671 02ba 0E94 0000 		call readpacket
 672               	.LVL43:
 219:libs/dynamixel/dynamixel.c **** 				return status;
 673               		.loc 1 219 0
 674 02be 8130      		cpi r24,lo8(1)
 675 02c0 01F0      		breq .L51
 676               	.LVL44:
 677 02c2 1150      		subi r17,lo8(-(-1))
 678               	.LVL45:
 200:libs/dynamixel/dynamixel.c **** 		// Write packet	
 679               		.loc 1 200 0 discriminator 2
 680 02c4 01F0      		breq .+2
 681 02c6 00C0      		rjmp .L52
 682               	.LVL46:
 683               	.L49:
 684               	/* epilogue start */
 685               	.LBE16:
 224:libs/dynamixel/dynamixel.c **** 		}
 225:libs/dynamixel/dynamixel.c **** 	}
 226:libs/dynamixel/dynamixel.c **** 		
 227:libs/dynamixel/dynamixel.c **** 	return status;
 228:libs/dynamixel/dynamixel.c **** }
 686               		.loc 1 228 0
 687 02c8 DF91      		pop r29
 688 02ca CF91      		pop r28
 689               	.LVL47:
 690 02cc 1F91      		pop r17
 691 02ce 0F91      		pop r16
 692 02d0 FF90      		pop r15
 693 02d2 EF90      		pop r14
 694               	.LVL48:
 695 02d4 DF90      		pop r13
 696               	.LVL49:
 697 02d6 0895      		ret
 698               		.cfi_endproc
 699               	.LFE19:
 701               	.global	dynamixel_rx_txrx
 703               	dynamixel_rx_txrx:
 704               	.LFB20:
 229:libs/dynamixel/dynamixel.c **** 
 230:libs/dynamixel/dynamixel.c **** uint8_t dynamixel_rx_txrx(volatile uint8_t* txpacket, volatile uint8_t* rxpacket) {
 705               		.loc 1 230 0
 706               		.cfi_startproc
 707               	.LVL50:
 708 02d8 DF92      		push r13
 709               	.LCFI19:
 710               		.cfi_def_cfa_offset 3
 711               		.cfi_offset 13, -2
 712 02da EF92      		push r14
 713               	.LCFI20:
 714               		.cfi_def_cfa_offset 4
 715               		.cfi_offset 14, -3
 716 02dc FF92      		push r15
 717               	.LCFI21:
 718               		.cfi_def_cfa_offset 5
 719               		.cfi_offset 15, -4
 720 02de 0F93      		push r16
 721               	.LCFI22:
 722               		.cfi_def_cfa_offset 6
 723               		.cfi_offset 16, -5
 724 02e0 1F93      		push r17
 725               	.LCFI23:
 726               		.cfi_def_cfa_offset 7
 727               		.cfi_offset 17, -6
 728 02e2 CF93      		push r28
 729               	.LCFI24:
 730               		.cfi_def_cfa_offset 8
 731               		.cfi_offset 28, -7
 732 02e4 DF93      		push r29
 733               	.LCFI25:
 734               		.cfi_def_cfa_offset 9
 735               		.cfi_offset 29, -8
 736               	/* prologue: function */
 737               	/* frame size = 0 */
 738               	/* stack size = 7 */
 739               	.L__stack_usage = 7
 740 02e6 EC01      		movw r28,r24
 741 02e8 7B01      		movw r14,r22
 742               	.LVL51:
 231:libs/dynamixel/dynamixel.c **** 	uint8_t rxlength = 0;
 232:libs/dynamixel/dynamixel.c **** 	uint8_t txlength = txpacket[DYNAMIXEL_LENGTH] + 4;
 743               		.loc 1 232 0
 744 02ea 8B81      		ldd r24,Y+3
 745               	.LVL52:
 746 02ec 94E0      		ldi r25,lo8(4)
 747 02ee D92E      		mov r13,r25
 748 02f0 D80E      		add r13,r24
 749               	.LVL53:
 233:libs/dynamixel/dynamixel.c **** 	
 234:libs/dynamixel/dynamixel.c **** 	txpacket[0] = (uint8_t) 0xff;
 750               		.loc 1 234 0
 751 02f2 8FEF      		ldi r24,lo8(-1)
 752 02f4 8883      		st Y,r24
 235:libs/dynamixel/dynamixel.c **** 	txpacket[1] = (uint8_t) 0xff;
 753               		.loc 1 235 0
 754 02f6 8983      		std Y+1,r24
 236:libs/dynamixel/dynamixel.c **** 	txpacket[txlength - 1] = (uint8_t)calculatechecksum(txpacket);
 755               		.loc 1 236 0
 756 02f8 0D2D      		mov r16,r13
 757 02fa 10E0      		ldi r17,0
 758 02fc 0150      		subi r16,1
 759 02fe 1109      		sbc r17,__zero_reg__
 760 0300 0C0F      		add r16,r28
 761 0302 1D1F      		adc r17,r29
 762 0304 CE01      		movw r24,r28
 763 0306 0E94 0000 		call calculatechecksum
 764               	.LVL54:
 765 030a F801      		movw r30,r16
 766 030c 8083      		st Z,r24
 237:libs/dynamixel/dynamixel.c **** 	
 238:libs/dynamixel/dynamixel.c **** 	rx_settx();
 767               		.loc 1 238 0
 768 030e 0E94 0000 		call rx_settx
 769               	.LVL55:
 770 0312 9C2F      		mov r25,r28
 771               	.LBB27:
 239:libs/dynamixel/dynamixel.c **** 	// Write packet	
 240:libs/dynamixel/dynamixel.c **** 	for(uint8_t i = 0; i < txlength; i++) {
 772               		.loc 1 240 0
 773 0314 EC2F      		mov r30,r28
 774 0316 FD2F      		mov r31,r29
 775               	.LVL56:
 776               	.L64:
 777 0318 8E2F      		mov r24,r30
 778 031a 891B      		sub r24,r25
 779               		.loc 1 240 0 is_stmt 0 discriminator 1
 780 031c 8D15      		cp r24,r13
 781 031e 00F4      		brsh .L72
 241:libs/dynamixel/dynamixel.c **** 		rx_write(txpacket[i]);
 782               		.loc 1 241 0 is_stmt 1 discriminator 3
 783 0320 8081      		ld r24,Z
 784               	.LVL57:
 785               	.L65:
 786               	.LBB28:
 787               	.LBB29:
 143:libs/dynamixel/dynamixel.c **** 	UDR1 = c;
 788               		.loc 1 143 0
 789 0322 2091 C800 		lds r18,200
 790 0326 25FF      		sbrs r18,5
 791 0328 00C0      		rjmp .L65
 144:libs/dynamixel/dynamixel.c **** }
 792               		.loc 1 144 0
 793 032a 8093 CE00 		sts 206,r24
 794               	.LVL58:
 795 032e 3196      		adiw r30,1
 796               	.LVL59:
 797 0330 00C0      		rjmp .L64
 798               	.LVL60:
 799               	.L72:
 800               	.LBE29:
 801               	.LBE28:
 802               	.LBE27:
 242:libs/dynamixel/dynamixel.c **** 	}
 243:libs/dynamixel/dynamixel.c **** 	rx_setrx();
 803               		.loc 1 243 0
 804 0332 0E94 0000 		call rx_setrx
 805               	.LVL61:
 244:libs/dynamixel/dynamixel.c **** 	
 245:libs/dynamixel/dynamixel.c **** 	// Read response
 246:libs/dynamixel/dynamixel.c **** 	if(txpacket[DYNAMIXEL_ID] != DYNAMIXEL_BROADCAST_ID) {	
 806               		.loc 1 246 0
 807 0336 8A81      		ldd r24,Y+2
 808 0338 8E3F      		cpi r24,lo8(-2)
 809 033a 01F0      		breq .L67
 247:libs/dynamixel/dynamixel.c **** 		if(txpacket[DYNAMIXEL_INSTRUCTION] == DYNAMIXEL_READ) {
 810               		.loc 1 247 0
 811 033c 8C81      		ldd r24,Y+4
 812 033e 8230      		cpi r24,lo8(2)
 813 0340 01F4      		brne .L69
 248:libs/dynamixel/dynamixel.c **** 			rxlength = txpacket[DYNAMIXEL_PARAMETER + 1] + 6;
 814               		.loc 1 248 0
 815 0342 6E81      		ldd r22,Y+6
 816 0344 6A5F      		subi r22,lo8(-(6))
 817               	.LVL62:
 818 0346 00C0      		rjmp .L68
 819               	.LVL63:
 820               	.L69:
 249:libs/dynamixel/dynamixel.c **** 		}
 250:libs/dynamixel/dynamixel.c **** 		else {
 251:libs/dynamixel/dynamixel.c **** 			rxlength = 6;
 821               		.loc 1 251 0
 822 0348 66E0      		ldi r22,lo8(6)
 823               	.LVL64:
 824               	.L68:
 252:libs/dynamixel/dynamixel.c **** 		}
 253:libs/dynamixel/dynamixel.c **** 		return readpacket(rxpacket, rxlength, rx_buffer, &rx_buffer_index);
 825               		.loc 1 253 0
 826 034a 20E0      		ldi r18,lo8(rx_buffer_index)
 827 034c 30E0      		ldi r19,hi8(rx_buffer_index)
 828 034e 40E0      		ldi r20,lo8(rx_buffer)
 829 0350 50E0      		ldi r21,hi8(rx_buffer)
 830 0352 C701      		movw r24,r14
 831               	/* epilogue start */
 254:libs/dynamixel/dynamixel.c **** 	}
 255:libs/dynamixel/dynamixel.c **** 		
 256:libs/dynamixel/dynamixel.c **** 	return DYNAMIXEL_SUCCESS;
 257:libs/dynamixel/dynamixel.c **** }
 832               		.loc 1 257 0
 833 0354 DF91      		pop r29
 834 0356 CF91      		pop r28
 835               	.LVL65:
 836 0358 1F91      		pop r17
 837 035a 0F91      		pop r16
 838 035c FF90      		pop r15
 839 035e EF90      		pop r14
 840               	.LVL66:
 841 0360 DF90      		pop r13
 842               	.LVL67:
 253:libs/dynamixel/dynamixel.c **** 	}
 843               		.loc 1 253 0
 844 0362 0C94 0000 		jmp readpacket
 845               	.LVL68:
 846               	.L67:
 847               		.loc 1 257 0
 848 0366 81E0      		ldi r24,lo8(1)
 849               	/* epilogue start */
 850 0368 DF91      		pop r29
 851 036a CF91      		pop r28
 852               	.LVL69:
 853 036c 1F91      		pop r17
 854 036e 0F91      		pop r16
 855 0370 FF90      		pop r15
 856 0372 EF90      		pop r14
 857               	.LVL70:
 858 0374 DF90      		pop r13
 859               	.LVL71:
 860 0376 0895      		ret
 861               		.cfi_endproc
 862               	.LFE20:
 864               		.local	rx_buffer_index
 865               		.comm	rx_buffer_index,1,1
 866               		.local	rx_buffer
 867               		.comm	rx_buffer,256,1
 868               		.local	ax_buffer_index
 869               		.comm	ax_buffer_index,1,1
 870               		.local	ax_buffer
 871               		.comm	ax_buffer,256,1
 872               	.Letext0:
 873               		.file 3 "/usr/lib/avr/include/stdint.h"
 874               		.file 4 "/usr/lib/gcc/avr/4.9.2/include/stddef.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 dynamixel.c
     /tmp/ccaqE5vW.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccaqE5vW.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccaqE5vW.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccaqE5vW.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccaqE5vW.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccaqE5vW.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccaqE5vW.s:12     .text:0000000000000000 calculatechecksum
     /tmp/ccaqE5vW.s:67     .text:0000000000000030 readpacket
     /tmp/ccaqE5vW.s:188    .text:00000000000000a4 __vector_21
     /tmp/ccaqE5vW.s:867    .bss:0000000000000101 ax_buffer_index
     /tmp/ccaqE5vW.s:869    .bss:0000000000000102 ax_buffer
     /tmp/ccaqE5vW.s:292    .text:0000000000000128 __vector_32
                             .bss:0000000000000000 rx_buffer_index
     /tmp/ccaqE5vW.s:865    .bss:0000000000000001 rx_buffer
     /tmp/ccaqE5vW.s:369    .text:0000000000000186 dynamixel_ax_init
     /tmp/ccaqE5vW.s:414    .text:00000000000001ba dynamixel_rx_init
     /tmp/ccaqE5vW.s:463    .text:00000000000001f2 rx_setrx
     /tmp/ccaqE5vW.s:484    .text:0000000000000200 rx_settx
     /tmp/ccaqE5vW.s:500    .text:0000000000000204 dynamixel_ax_txrx
     /tmp/ccaqE5vW.s:703    .text:00000000000002d8 dynamixel_rx_txrx

UNDEFINED SYMBOLS
__do_clear_bss
