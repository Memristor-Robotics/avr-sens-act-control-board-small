   1               		.file	"PwmBrushless.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	PWM_SetDuty:
  13               	.LFB13:
  14               		.file 1 "src/PwmBrushless.c"
   1:src/PwmBrushless.c **** #include "PwmBrushless.h"
   2:src/PwmBrushless.c **** 
   3:src/PwmBrushless.c **** #define BRUSHLESS_ACC_COEF 20
   4:src/PwmBrushless.c **** 
   5:src/PwmBrushless.c **** static void PWM_SetDuty(uint16_t promil);
   6:src/PwmBrushless.c **** 
   7:src/PwmBrushless.c **** static uint8_t CurrentSpeed = 0;
   8:src/PwmBrushless.c **** 
   9:src/PwmBrushless.c **** void Brushless_Calibration(void) {
  10:src/PwmBrushless.c **** 
  11:src/PwmBrushless.c ****   PWM_SetDuty(100);
  12:src/PwmBrushless.c ****   _delay_ms(8000);
  13:src/PwmBrushless.c ****   PWM_SetDuty(50);
  14:src/PwmBrushless.c ****   _delay_ms(2000);
  15:src/PwmBrushless.c **** 
  16:src/PwmBrushless.c **** }
  17:src/PwmBrushless.c **** 
  18:src/PwmBrushless.c **** void Brushless_Init(Pin* pin) {
  19:src/PwmBrushless.c **** 
  20:src/PwmBrushless.c ****   Pin_SetMode(pin, PIN_OUTPUT);
  21:src/PwmBrushless.c **** 
  22:src/PwmBrushless.c ****   *(pin->timer->TCCRnA) |= (1 << pin->timer->COMnA1) | (1 << pin->timer->WGMn1);
  23:src/PwmBrushless.c ****   *(pin->timer->TCCRnB) |= (1 << pin->timer->WGMn3) | (1 << pin->timer->CSn1);
  24:src/PwmBrushless.c ****   *(pin->timer->ICRn) = MAX_OCR;
  25:src/PwmBrushless.c **** 
  26:src/PwmBrushless.c ****   PWM_SetDuty(50);
  27:src/PwmBrushless.c ****   
  28:src/PwmBrushless.c **** 
  29:src/PwmBrushless.c **** }
  30:src/PwmBrushless.c **** 
  31:src/PwmBrushless.c **** // duty cycle (0 pr-1000 pr)
  32:src/PwmBrushless.c **** void PWM_SetDuty(uint16_t promil) {
  15               		.loc 1 32 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  33:src/PwmBrushless.c **** 
  34:src/PwmBrushless.c ****   if(promil > 100) {
  22               		.loc 1 34 0
  23 0000 8536      		cpi r24,101
  24 0002 9105      		cpc r25,__zero_reg__
  25 0004 00F4      		brsh .L3
  35:src/PwmBrushless.c ****     promil = 100;
  36:src/PwmBrushless.c ****   } else if(promil < 50) {
  26               		.loc 1 36 0
  27 0006 8233      		cpi r24,50
  28 0008 9105      		cpc r25,__zero_reg__
  29 000a 00F4      		brsh .L2
  37:src/PwmBrushless.c ****     promil = 50;
  30               		.loc 1 37 0
  31 000c 82E3      		ldi r24,lo8(50)
  32 000e 90E0      		ldi r25,0
  33               	.LVL1:
  34 0010 00C0      		rjmp .L2
  35               	.LVL2:
  36               	.L3:
  35:src/PwmBrushless.c ****     promil = 100;
  37               		.loc 1 35 0
  38 0012 84E6      		ldi r24,lo8(100)
  39 0014 90E0      		ldi r25,0
  40               	.LVL3:
  41               	.L2:
  38:src/PwmBrushless.c ****   }
  39:src/PwmBrushless.c **** 
  40:src/PwmBrushless.c ****   uint16_t duty = 20 * promil;
  42               		.loc 1 40 0
  43 0016 44E1      		ldi r20,lo8(20)
  44 0018 489F      		mul r20,r24
  45 001a 9001      		movw r18,r0
  46 001c 499F      		mul r20,r25
  47 001e 300D      		add r19,r0
  48 0020 1124      		clr __zero_reg__
  49               	.LVL4:
  41:src/PwmBrushless.c **** 
  42:src/PwmBrushless.c ****   OCR1A = duty;
  50               		.loc 1 42 0
  51 0022 3093 8900 		sts 136+1,r19
  52 0026 2093 8800 		sts 136,r18
  53 002a 0895      		ret
  54               		.cfi_endproc
  55               	.LFE13:
  57               	.global	Brushless_Calibration
  59               	Brushless_Calibration:
  60               	.LFB11:
   9:src/PwmBrushless.c **** 
  61               		.loc 1 9 0
  62               		.cfi_startproc
  63               	/* prologue: function */
  64               	/* frame size = 0 */
  65               	/* stack size = 0 */
  66               	.L__stack_usage = 0
  67               	.LVL5:
  68               	.LBB19:
  69               	.LBB20:
  70               		.loc 1 42 0
  71 002c E8E8      		ldi r30,lo8(-120)
  72 002e F0E0      		ldi r31,0
  73 0030 80ED      		ldi r24,lo8(-48)
  74 0032 97E0      		ldi r25,lo8(7)
  75 0034 9183      		std Z+1,r25
  76 0036 8083      		st Z,r24
  77               	.LVL6:
  78               	.LBE20:
  79               	.LBE19:
  80               	.LBB21:
  81               	.LBB22:
  82               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  83               		.loc 2 163 0
  84 0038 24E5      		ldi r18,lo8(21333332)
  85 003a 35E8      		ldi r19,hi8(21333332)
  86 003c 85E4      		ldi r24,hlo8(21333332)
  87 003e 91E0      		ldi r25,hhi8(21333332)
  88 0040 2150      	1:	subi r18,1
  89 0042 3040      		sbci r19,0
  90 0044 8040      		sbci r24,0
  91 0046 9040      		sbci r25,0
  92 0048 01F4      		brne 1b
  93 004a 00C0      		rjmp .
  94 004c 00C0      		rjmp .
  95 004e 0000      		nop
  96               	.LVL7:
  97               	.LBE22:
  98               	.LBE21:
  99               	.LBB23:
 100               	.LBB24:
 101               		.loc 1 42 0
 102 0050 88EE      		ldi r24,lo8(-24)
 103 0052 93E0      		ldi r25,lo8(3)
 104 0054 9183      		std Z+1,r25
 105 0056 8083      		st Z,r24
 106               	.LVL8:
 107               	.LBE24:
 108               	.LBE23:
 109               	.LBB25:
 110               	.LBB26:
 111               		.loc 2 163 0
 112 0058 2FEF      		ldi r18,lo8(6399999)
 113 005a 37EA      		ldi r19,hi8(6399999)
 114 005c 81E6      		ldi r24,hlo8(6399999)
 115 005e 2150      	1:	subi r18,1
 116 0060 3040      		sbci r19,0
 117 0062 8040      		sbci r24,0
 118 0064 01F4      		brne 1b
 119 0066 00C0      		rjmp .
 120 0068 0000      		nop
 121 006a 0895      		ret
 122               	.LBE26:
 123               	.LBE25:
 124               		.cfi_endproc
 125               	.LFE11:
 127               	.global	Brushless_Init
 129               	Brushless_Init:
 130               	.LFB12:
  18:src/PwmBrushless.c **** 
 131               		.loc 1 18 0
 132               		.cfi_startproc
 133               	.LVL9:
 134 006c CF93      		push r28
 135               	.LCFI0:
 136               		.cfi_def_cfa_offset 3
 137               		.cfi_offset 28, -2
 138 006e DF93      		push r29
 139               	.LCFI1:
 140               		.cfi_def_cfa_offset 4
 141               		.cfi_offset 29, -3
 142               	/* prologue: function */
 143               	/* frame size = 0 */
 144               	/* stack size = 2 */
 145               	.L__stack_usage = 2
 146 0070 EC01      		movw r28,r24
  20:src/PwmBrushless.c **** 
 147               		.loc 1 20 0
 148 0072 61E0      		ldi r22,lo8(1)
 149 0074 0E94 0000 		call Pin_SetMode
 150               	.LVL10:
  22:src/PwmBrushless.c ****   *(pin->timer->TCCRnB) |= (1 << pin->timer->WGMn3) | (1 << pin->timer->CSn1);
 151               		.loc 1 22 0
 152 0078 EF81      		ldd r30,Y+7
 153 007a F885      		ldd r31,Y+8
 154 007c A081      		ld r26,Z
 155 007e B181      		ldd r27,Z+1
 156 0080 9C91      		ld r25,X
 157 0082 21E0      		ldi r18,lo8(1)
 158 0084 30E0      		ldi r19,0
 159 0086 B901      		movw r22,r18
 160 0088 0484      		ldd r0,Z+12
 161 008a 00C0      		rjmp 2f
 162               		1:
 163 008c 660F      		lsl r22
 164 008e 771F      		rol r23
 165               		2:
 166 0090 0A94      		dec r0
 167 0092 02F4      		brpl 1b
 168 0094 A901      		movw r20,r18
 169 0096 0184      		ldd r0,Z+9
 170 0098 00C0      		rjmp 2f
 171               		1:
 172 009a 440F      		lsl r20
 173 009c 551F      		rol r21
 174               		2:
 175 009e 0A94      		dec r0
 176 00a0 02F4      		brpl 1b
 177 00a2 862F      		mov r24,r22
 178 00a4 842B      		or r24,r20
 179 00a6 892B      		or r24,r25
 180 00a8 8C93      		st X,r24
  23:src/PwmBrushless.c ****   *(pin->timer->ICRn) = MAX_OCR;
 181               		.loc 1 23 0
 182 00aa EF81      		ldd r30,Y+7
 183 00ac F885      		ldd r31,Y+8
 184 00ae A281      		ldd r26,Z+2
 185 00b0 B381      		ldd r27,Z+3
 186 00b2 8C91      		ld r24,X
 187 00b4 A901      		movw r20,r18
 188 00b6 0384      		ldd r0,Z+11
 189 00b8 00C0      		rjmp 2f
 190               		1:
 191 00ba 440F      		lsl r20
 192 00bc 551F      		rol r21
 193               		2:
 194 00be 0A94      		dec r0
 195 00c0 02F4      		brpl 1b
 196 00c2 0684      		ldd r0,Z+14
 197 00c4 00C0      		rjmp 2f
 198               		1:
 199 00c6 220F      		lsl r18
 200 00c8 331F      		rol r19
 201               		2:
 202 00ca 0A94      		dec r0
 203 00cc 02F4      		brpl 1b
 204 00ce 242B      		or r18,r20
 205 00d0 282B      		or r18,r24
 206 00d2 2C93      		st X,r18
  24:src/PwmBrushless.c **** 
 207               		.loc 1 24 0
 208 00d4 EF81      		ldd r30,Y+7
 209 00d6 F885      		ldd r31,Y+8
 210 00d8 0680      		ldd __tmp_reg__,Z+6
 211 00da F781      		ldd r31,Z+7
 212 00dc E02D      		mov r30,__tmp_reg__
 213 00de 80E2      		ldi r24,lo8(32)
 214 00e0 9EE4      		ldi r25,lo8(78)
 215 00e2 9183      		std Z+1,r25
 216 00e4 8083      		st Z,r24
 217               	.LVL11:
 218               	.LBB29:
 219               	.LBB30:
 220               		.loc 1 42 0
 221 00e6 88EE      		ldi r24,lo8(-24)
 222 00e8 93E0      		ldi r25,lo8(3)
 223 00ea 9093 8900 		sts 136+1,r25
 224 00ee 8093 8800 		sts 136,r24
 225               	/* epilogue start */
 226               	.LBE30:
 227               	.LBE29:
  29:src/PwmBrushless.c **** 
 228               		.loc 1 29 0
 229 00f2 DF91      		pop r29
 230 00f4 CF91      		pop r28
 231               	.LVL12:
 232 00f6 0895      		ret
 233               		.cfi_endproc
 234               	.LFE12:
 236               	.global	__floatunsisf
 237               	.global	__mulsf3
 238               	.global	__addsf3
 239               	.global	__fixunssfsi
 240               	.global	__floatsisf
 241               	.global	Brushless_OnMessage
 243               	Brushless_OnMessage:
 244               	.LFB14:
  43:src/PwmBrushless.c **** 
  44:src/PwmBrushless.c **** }
  45:src/PwmBrushless.c **** 
  46:src/PwmBrushless.c **** // speed (50 pr - 100 pr)
  47:src/PwmBrushless.c **** bool Brushless_OnMessage(can_t* canMsg) {
 245               		.loc 1 47 0
 246               		.cfi_startproc
 247               	.LVL13:
 248 00f8 FF92      		push r15
 249               	.LCFI2:
 250               		.cfi_def_cfa_offset 3
 251               		.cfi_offset 15, -2
 252 00fa 0F93      		push r16
 253               	.LCFI3:
 254               		.cfi_def_cfa_offset 4
 255               		.cfi_offset 16, -3
 256 00fc 1F93      		push r17
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 5
 259               		.cfi_offset 17, -4
 260 00fe CF93      		push r28
 261               	.LCFI5:
 262               		.cfi_def_cfa_offset 6
 263               		.cfi_offset 28, -5
 264 0100 DF93      		push r29
 265               	.LCFI6:
 266               		.cfi_def_cfa_offset 7
 267               		.cfi_offset 29, -6
 268               	/* prologue: function */
 269               	/* frame size = 0 */
 270               	/* stack size = 5 */
 271               	.L__stack_usage = 5
 272               	.LVL14:
  48:src/PwmBrushless.c **** 
  49:src/PwmBrushless.c ****   size_t i = 0;
  50:src/PwmBrushless.c **** 
  51:src/PwmBrushless.c ****   if(canMsg->id == BRUSHLESS_CANID) {
 273               		.loc 1 51 0
 274 0102 FC01      		movw r30,r24
 275 0104 4081      		ld r20,Z
 276 0106 5181      		ldd r21,Z+1
 277 0108 6281      		ldd r22,Z+2
 278 010a 7381      		ldd r23,Z+3
 279 010c 4335      		cpi r20,83
 280 010e 5D48      		sbci r21,-115
 281 0110 6105      		cpc r22,__zero_reg__
 282 0112 7105      		cpc r23,__zero_reg__
 283 0114 01F0      		breq .+2
 284 0116 00C0      		rjmp .L17
 285 0118 FC01      		movw r30,r24
 286               	.LBB31:
  52:src/PwmBrushless.c **** 
  53:src/PwmBrushless.c ****     uint8_t speed = canMsg->data[0];
 287               		.loc 1 53 0
 288 011a F680      		ldd r15,Z+6
 289               	.LVL15:
  54:src/PwmBrushless.c **** 
  55:src/PwmBrushless.c ****     if(speed > CurrentSpeed) {
 290               		.loc 1 55 0
 291 011c C091 0000 		lds r28,CurrentSpeed
 292 0120 0F2D      		mov r16,r15
 293 0122 10E0      		ldi r17,0
 294 0124 CF15      		cp r28,r15
 295 0126 00F4      		brsh .L9
  56:src/PwmBrushless.c ****       for(i = CurrentSpeed; i < speed; i++) {
 296               		.loc 1 56 0
 297 0128 D0E0      		ldi r29,0
 298               	.LVL16:
 299               	.L10:
 300               		.loc 1 56 0 is_stmt 0 discriminator 1
 301 012a C017      		cp r28,r16
 302 012c D107      		cpc r29,r17
 303 012e 00F0      		brlo .+2
 304 0130 00C0      		rjmp .L12
  57:src/PwmBrushless.c ****           PWM_SetDuty((uint16_t)(50 + (50.0 / 255.0) * i + 0.5));
 305               		.loc 1 57 0 is_stmt 1 discriminator 3
 306 0132 BE01      		movw r22,r28
 307 0134 80E0      		ldi r24,0
 308 0136 90E0      		ldi r25,0
 309 0138 0E94 0000 		call __floatunsisf
 310               	.LVL17:
 311 013c 29EC      		ldi r18,lo8(-55)
 312 013e 38EC      		ldi r19,lo8(-56)
 313 0140 48E4      		ldi r20,lo8(72)
 314 0142 5EE3      		ldi r21,lo8(62)
 315 0144 0E94 0000 		call __mulsf3
 316               	.LVL18:
 317 0148 20E0      		ldi r18,0
 318 014a 30E0      		ldi r19,0
 319 014c 48E4      		ldi r20,lo8(72)
 320 014e 52E4      		ldi r21,lo8(66)
 321 0150 0E94 0000 		call __addsf3
 322               	.LVL19:
 323 0154 20E0      		ldi r18,0
 324 0156 30E0      		ldi r19,0
 325 0158 40E0      		ldi r20,0
 326 015a 5FE3      		ldi r21,lo8(63)
 327 015c 0E94 0000 		call __addsf3
 328               	.LVL20:
 329 0160 0E94 0000 		call __fixunssfsi
 330               	.LVL21:
 331 0164 CB01      		movw r24,r22
 332 0166 0E94 0000 		call PWM_SetDuty
 333               	.LVL22:
 334               	.LBB32:
 335               	.LBB33:
 336               		.loc 2 163 0 discriminator 3
 337 016a 2FEF      		ldi r18,lo8(63999)
 338 016c 89EF      		ldi r24,hi8(63999)
 339 016e 90E0      		ldi r25,hlo8(63999)
 340 0170 2150      	1:	subi r18,1
 341 0172 8040      		sbci r24,0
 342 0174 9040      		sbci r25,0
 343 0176 01F4      		brne 1b
 344 0178 00C0      		rjmp .
 345 017a 0000      		nop
 346               	.LBE33:
 347               	.LBE32:
  56:src/PwmBrushless.c ****       for(i = CurrentSpeed; i < speed; i++) {
 348               		.loc 1 56 0 discriminator 3
 349 017c 2196      		adiw r28,1
 350               	.LVL23:
 351 017e 00C0      		rjmp .L10
 352               	.LVL24:
 353               	.L9:
  58:src/PwmBrushless.c ****           _delay_ms(BRUSHLESS_ACC_COEF);
  59:src/PwmBrushless.c ****         }
  60:src/PwmBrushless.c ****     } else if(speed < CurrentSpeed) {
 354               		.loc 1 60 0
 355 0180 FC16      		cp r15,r28
 356 0182 00F4      		brsh .L13
  61:src/PwmBrushless.c ****       for(i = CurrentSpeed; i > speed; i--) {
 357               		.loc 1 61 0
 358 0184 D0E0      		ldi r29,0
 359               	.LVL25:
 360               	.L14:
 361               		.loc 1 61 0 is_stmt 0 discriminator 1
 362 0186 0C17      		cp r16,r28
 363 0188 1D07      		cpc r17,r29
 364 018a 00F4      		brsh .L12
  62:src/PwmBrushless.c ****         PWM_SetDuty((uint16_t)(50 + (50.0 / 255) * i));
 365               		.loc 1 62 0 is_stmt 1 discriminator 3
 366 018c BE01      		movw r22,r28
 367 018e 80E0      		ldi r24,0
 368 0190 90E0      		ldi r25,0
 369 0192 0E94 0000 		call __floatunsisf
 370               	.LVL26:
 371 0196 29EC      		ldi r18,lo8(-55)
 372 0198 38EC      		ldi r19,lo8(-56)
 373 019a 48E4      		ldi r20,lo8(72)
 374 019c 5EE3      		ldi r21,lo8(62)
 375 019e 0E94 0000 		call __mulsf3
 376               	.LVL27:
 377 01a2 20E0      		ldi r18,0
 378 01a4 30E0      		ldi r19,0
 379 01a6 48E4      		ldi r20,lo8(72)
 380 01a8 52E4      		ldi r21,lo8(66)
 381 01aa 0E94 0000 		call __addsf3
 382               	.LVL28:
 383 01ae 0E94 0000 		call __fixunssfsi
 384               	.LVL29:
 385 01b2 CB01      		movw r24,r22
 386 01b4 0E94 0000 		call PWM_SetDuty
 387               	.LVL30:
 388               	.LBB34:
 389               	.LBB35:
 390               		.loc 2 163 0 discriminator 3
 391 01b8 EFEF      		ldi r30,lo8(63999)
 392 01ba F9EF      		ldi r31,hi8(63999)
 393 01bc 20E0      		ldi r18,hlo8(63999)
 394 01be E150      	1:	subi r30,1
 395 01c0 F040      		sbci r31,0
 396 01c2 2040      		sbci r18,0
 397 01c4 01F4      		brne 1b
 398 01c6 00C0      		rjmp .
 399 01c8 0000      		nop
 400               	.LBE35:
 401               	.LBE34:
  61:src/PwmBrushless.c ****       for(i = CurrentSpeed; i > speed; i--) {
 402               		.loc 1 61 0 discriminator 3
 403 01ca 2197      		sbiw r28,1
 404               	.LVL31:
 405 01cc 00C0      		rjmp .L14
 406               	.LVL32:
 407               	.L13:
  63:src/PwmBrushless.c ****         _delay_ms(BRUSHLESS_ACC_COEF);
  64:src/PwmBrushless.c ****       }
  65:src/PwmBrushless.c ****     } else {
  66:src/PwmBrushless.c ****       PWM_SetDuty((uint16_t)(50 + (50.0 / 255) * speed));
 408               		.loc 1 66 0
 409 01ce B801      		movw r22,r16
 410 01d0 110F      		lsl r17
 411 01d2 880B      		sbc r24,r24
 412 01d4 990B      		sbc r25,r25
 413 01d6 0E94 0000 		call __floatsisf
 414               	.LVL33:
 415 01da 29EC      		ldi r18,lo8(-55)
 416 01dc 38EC      		ldi r19,lo8(-56)
 417 01de 48E4      		ldi r20,lo8(72)
 418 01e0 5EE3      		ldi r21,lo8(62)
 419 01e2 0E94 0000 		call __mulsf3
 420               	.LVL34:
 421 01e6 20E0      		ldi r18,0
 422 01e8 30E0      		ldi r19,0
 423 01ea 48E4      		ldi r20,lo8(72)
 424 01ec 52E4      		ldi r21,lo8(66)
 425 01ee 0E94 0000 		call __addsf3
 426               	.LVL35:
 427 01f2 0E94 0000 		call __fixunssfsi
 428               	.LVL36:
 429 01f6 CB01      		movw r24,r22
 430 01f8 0E94 0000 		call PWM_SetDuty
 431               	.LVL37:
 432               	.L12:
  67:src/PwmBrushless.c ****     }
  68:src/PwmBrushless.c **** 
  69:src/PwmBrushless.c ****     CurrentSpeed = speed;
 433               		.loc 1 69 0
 434 01fc F092 0000 		sts CurrentSpeed,r15
  70:src/PwmBrushless.c **** 
  71:src/PwmBrushless.c ****     return true;
 435               		.loc 1 71 0
 436 0200 81E0      		ldi r24,lo8(1)
 437 0202 00C0      		rjmp .L8
 438               	.LVL38:
 439               	.L17:
 440               	.LBE31:
  72:src/PwmBrushless.c ****   }
  73:src/PwmBrushless.c **** 
  74:src/PwmBrushless.c ****   return false;
 441               		.loc 1 74 0
 442 0204 80E0      		ldi r24,0
 443               	.LVL39:
 444               	.L8:
 445               	/* epilogue start */
  75:src/PwmBrushless.c **** }
 446               		.loc 1 75 0
 447 0206 DF91      		pop r29
 448 0208 CF91      		pop r28
 449 020a 1F91      		pop r17
 450 020c 0F91      		pop r16
 451 020e FF90      		pop r15
 452 0210 0895      		ret
 453               		.cfi_endproc
 454               	.LFE14:
 456               		.local	CurrentSpeed
 457               		.comm	CurrentSpeed,1,1
 458               	.Letext0:
 459               		.file 3 "/usr/lib/avr/include/stdint.h"
 460               		.file 4 "/usr/lib/gcc/avr/4.9.2/include/stddef.h"
 461               		.file 5 "./libs/can/can.h"
 462               		.file 6 "src/Pin.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 PwmBrushless.c
     /tmp/ccsoxEg3.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccsoxEg3.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccsoxEg3.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccsoxEg3.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccsoxEg3.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccsoxEg3.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccsoxEg3.s:12     .text:0000000000000000 PWM_SetDuty
     /tmp/ccsoxEg3.s:59     .text:000000000000002c Brushless_Calibration
     /tmp/ccsoxEg3.s:129    .text:000000000000006c Brushless_Init
     /tmp/ccsoxEg3.s:243    .text:00000000000000f8 Brushless_OnMessage
                             .bss:0000000000000000 CurrentSpeed

UNDEFINED SYMBOLS
Pin_SetMode
__floatunsisf
__mulsf3
__addsf3
__fixunssfsi
__floatsisf
__do_clear_bss
